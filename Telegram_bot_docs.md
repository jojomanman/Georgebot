The Complete Developer's Guide to the Modern Telegram Bot API: From Local Development to AI IntegrationPart I: The Bot API FoundationSection 1: Architecting Your Telegram BotThis section establishes the foundational knowledge required to begin development. It covers the creation process, the critical role of the API token, and the strategic choice between different API interaction paradigms.1.1 Introduction to the Telegram API Ecosystem: Bot API vs. MTProtoThe Telegram platform provides developers with two primary avenues for programmatic interaction: the high-level Bot API and the low-level Telegram API, which utilizes the Mobile Transport Protocol (MTProto).1 Understanding the distinction between these two is the first critical step in architecting a robust and maintainable bot.The Bot API is a simplified, HTTP-based interface designed explicitly for creating bots. It functions as an intermediary layer where Telegram's own servers handle the complex tasks of encryption and communication with the core Telegram infrastructure via MTProto.1 Developers interact with this layer by sending standard HTTPS requests to specific endpoints, making it accessible from virtually any programming language or platform that can perform web requests.3 This strategic abstraction is the primary reason for the platform's thriving bot ecosystem; it significantly lowers the barrier to entry by removing the need for developers to implement a custom, complex, and encrypted binary protocol.1 For the vast majority of bot use cases, including those involving advanced features like Mini Apps and AI integration, the Bot API is the intended and most appropriate choice.The Telegram API and TDLib (Telegram Database Library), on the other hand, offer direct access to the MTProto protocol.1 This is the same API that official Telegram clients (iOS, Android, Desktop) use. Building a client with this API grants access to the full spectrum of Telegram features, including those not exposed to bots, such as managing a user's own account, reading the full chat history of any conversation the user is in, and initiating conversations. This power comes at the cost of significantly increased complexity. Libraries like Telethon and Pyrogram in the Python ecosystem are MTProto-based clients, offering advantages over Bot API wrappers such as lower network overhead and access to user-level functionalities.5 However, they are designed for building custom clients or "userbots," not standard bots that interact with users through the official platform framework.A notable hybrid option is the ability to run a Local Bot API Server.2 This involves hosting an official, open-source application provided by Telegram that translates Bot API requests into MTProto requests locally. This setup provides some benefits of a direct MTProto connection—such as the ability to handle much larger file uploads (up to 2000 MB) and downloads, and receive local file paths directly—while still allowing the developer to code against the familiar and simpler HTTP-based Bot API interface.2For the purposes of this guide, and for the development of a standard, user-facing bot, all tutorials and examples will utilize the official, hosted Bot API. This approach offers the best balance of capability, simplicity, and maintainability.1.2 The First Step: A Comprehensive @BotFather TutorialAll Telegram bots are born from and managed by a single, official bot: @BotFather. This administrative bot serves as the central hub for creating new bots, managing existing ones, and configuring their settings.7 The process is entirely conversational.1. Creating a New BotThe journey begins by initiating a chat with @BotFather in any Telegram client and issuing the /newbot command.Initiate Contact: Search for @BotFather (it will have a blue verification checkmark) and start a chat.Send the Command: Type and send the /newbot command.Choose a Name: BotFather will ask for a name for your bot. This is the public-facing display name that users will see in their chat list and at the top of the conversation. It can contain spaces and emojis (e.g., "My Awesome AI Assistant").Choose a Username: Next, you must provide a unique username. This username is the bot's handle within Telegram. It must adhere to specific rules:It must be between 5 and 32 characters long.It can only contain Latin characters, numbers, and underscores.It is case-insensitive.Crucially, it must end with the suffix "bot" (e.g., MyAwesomeAI_bot).9Receive the API Token: Upon successful creation, BotFather will respond with a congratulatory message that includes your bot's API token. This token is a long string of characters, such as 4839574812:AAFD39kkdpWt3ywyRZergyOLMaJhac60qc.8 This token is your bot's password; it grants anyone who possesses it complete control over your bot. It must be stored securely and never shared publicly.2. Essential Post-Creation ConfigurationAfter creation, it is best practice to immediately configure your bot's profile to provide users with necessary information and context. This is also done via commands to @BotFather./setdescription: This command sets the short text (up to 512 characters) that users see before they start the chat, under the heading "What can this bot do?". It should be a concise summary of your bot's purpose.11/setabouttext: This sets an even shorter text (up to 120 characters) that appears on the bot's profile page. This text is also sent when a user shares your bot with someone else.11/setuserpic: This allows you to upload a profile picture for your bot, which is essential for branding and recognition.11/setcommands: This command is crucial for user experience. It allows you to define a list of commands your bot supports, along with a short description for each. These commands will appear as suggestions when a user types / in the chat, and will populate the menu button by default.11Later in this guide, we will return to @BotFather to configure more advanced features like Mini Apps and Games.121.3 Securely Managing Your Bot Token and Local EnvironmentWith the API token in hand, the next step is to establish a secure and organized local development environment. This is a critical phase that prevents accidental exposure of credentials and ensures project dependencies are managed cleanly.1. Project Structure and Virtual EnvironmentA well-structured project is easier to manage and deploy. The first step is to create a dedicated directory for your bot and initialize a Python virtual environment within it. A virtual environment isolates the project's dependencies from the system's global Python installation, preventing version conflicts.14Create Project Directory:Bashmkdir my_telegram_bot
cd my_telegram_bot
Create and Activate Virtual Environment:Bashpython -m venv venv
# On macOS/Linux
source venv/bin/activate
# On Windows
venv\Scripts\activate.bat
Your command prompt should now be prefixed with (venv), indicating the virtual environment is active.2. Securing the API TokenHard-coding the API token directly into your source code is a severe security risk. If the code is ever committed to a public repository like GitHub, the token will be exposed, and malicious actors can take control of your bot.16 The standard best practice is to use environment variables.Create a .env file: In the root of your project directory, create a file named .env. This file will store your secret credentials.#.env
BOT_TOKEN="4839574812:AAFD39kkdpWt3ywyRZergyOLMaJhac60qc"
Install python-dotenv: This library allows your Python application to load the variables from the .env file into the environment at runtime.Bashpip install python-dotenv
Create a .gitignore file: To ensure your secret token and virtual environment files are never committed to version control, create a .gitignore file.#.gitignore
venv/
.envpycache/*.pyc```3. Installing the Bot LibraryThis guide will primarily use the python-telegram-bot library, a popular, feature-rich, and asynchronous wrapper for the Bot API.18Install the Library: With your virtual environment active, install the library using pip.Bashpip install "python-telegram-bot[ext]" --upgrade
The [ext] addition installs optional dependencies related to the telegram.ext submodule, which provides high-level classes for building bots, including handlers, a job queue, and more.18 This library is fully asynchronous and compatible with Python 3.9+.18Your local environment is now securely configured and ready for development.Section 2: The Update Lifecycle: Polling vs. WebhooksA bot's core function is to react to events, which Telegram calls "updates." There are two fundamentally different mechanisms for receiving these updates from Telegram's servers: long polling and webhooks. The choice between them is primarily dictated by the bot's environment: polling for local development and webhooks for production deployment.152.1 Long Polling (getUpdates): The Definitive Guide for Local DevelopmentLong polling is a "pull" mechanism. In this model, your bot's server initiates a connection to the Telegram API and explicitly asks, "Are there any new updates for me?".7 This method is called "long" polling because if no updates are available, the server does not immediately respond. Instead, it holds the request open for a specified duration (the timeout). If an update arrives during this period, the server sends it as a response. If the timeout is reached without any new updates, the server responds with an empty result, and the bot immediately sends a new request.22This method is the preferred choice for local development because it requires no public-facing IP address or domain name. Your bot can run on your local machine, behind any firewall or NAT, and still receive updates because it is the one initiating all network connections.16The getUpdates Method: Parameters and PayloadsThe getUpdates method is the cornerstone of polling. A precise understanding of its parameters is essential to avoid common pitfalls like receiving duplicate messages.Endpoint: POST https://api.telegram.org/bot<token>/getUpdatesParameters:offset (Optional, Integer): This is the most critical parameter for correct polling. It is an identifier of the first update to be returned. To prevent receiving the same updates repeatedly, you must set the offset to be one greater than the highest update_id among the previously received updates. When getUpdates is called with an offset, all updates with an update_id less than or equal to the provided offset are marked as confirmed on Telegram's servers and will not be sent again.7limit (Optional, Integer): Limits the number of updates to be retrieved in a single call. The value must be between 1 and 100. It defaults to 100.23timeout (Optional, Integer): Timeout in seconds for long polling. A value of 0 effectively turns it into short polling (the server responds immediately). For development, a positive value like 10 or 30 is recommended. This should be a positive integer.23allowed_updates (Optional, Array of String): A JSON-serialized list of the update types you want your bot to receive (e.g., ["message", "callback_query"]). If not specified, all update types except chat_member are returned by default. This can reduce unnecessary network traffic.23Payload Deep DiveRequest Structure (JSON Body):JSON{
    "offset": 123456789,
    "limit": 100,
    "timeout": 30,
    "allowed_updates": ["message", "edited_message", "callback_query"]
}
Success Payload Structure:A successful response will have "ok": true and a "result" field containing a JSON array of Update objects. If no updates are available after the timeout, the result array will be empty.JSON{
    "ok": true,
    "result": [
        {
            "update_id": 123456789,
            "message": {
                "message_id": 5,
                "from": {
                    "id": 987654321,
                    "is_bot": false,
                    "first_name": "John",
                    "username": "johndoe",
                    "language_code": "en"
                },
                "chat": {
                    "id": 987654321,
                    "first_name": "John",
                    "username": "johndoe",
                    "type": "private"
                },
                "date": 1678886400,
                "text": "/start"
            }
        }
    ]
}
The simplicity of long polling comes with a trade-off in latency and efficiency. There will always be a slight delay between a user's action and the bot's reception of the update. At scale, the constant cycle of opening and closing HTTP connections can be less efficient than the push-based webhook model. For these reasons, long polling is an excellent tool for development and for bots with very low traffic, but it is not the recommended solution for production applications that require real-time responsiveness.2.2 Webhooks (setWebhook): Production-Ready Setup and SecurityWebhooks represent a more advanced and efficient "push" model for receiving updates. Instead of the bot asking for updates, you provide Telegram with a public URL. Whenever a new update for your bot occurs, Telegram's servers will send an HTTPS POST request containing the JSON-serialized Update object directly to your specified URL.7This approach offers significant advantages for production environments:Lower Latency: Updates are delivered in near real-time, as they happen.27Efficiency: Your server is not burdened with maintaining a constant polling connection. It only consumes resources when there is an actual event to process.27However, this efficiency comes with a stricter set of technical requirements 7:HTTPS Required: The webhook URL must be served over HTTPS with a valid SSL/TLS certificate (TLS 1.2 or higher). Plain HTTP is not supported.7Supported Ports: Telegram will only send webhook requests to a limited set of standard ports: 443, 80, 88, and 8443.7Public Accessibility: The URL must be publicly accessible on the internet.The setWebhook Method: Parameters and PayloadsEndpoint: POST https://api.telegram.org/bot<token>/setWebhookParameters:url (Required, String): The HTTPS URL to which updates will be sent. To remove a webhook and switch back to polling, send an empty string.23certificate (Optional, InputFile): If you are using a self-signed SSL certificate, you must upload your public key certificate here. This is not needed for certificates from trusted Certificate Authorities.7ip_address (Optional, String): A fixed IP address that Telegram will use to send webhook requests, instead of resolving the domain via DNS.23max_connections (Optional, Integer): The maximum allowed number of simultaneous HTTPS connections for update delivery. Defaults to 40, with a range of 1-100. This can be tuned to manage the load on your server.23allowed_updates (Optional, Array of String): Same as in getUpdates, this filters which update types your webhook will receive.23drop_pending_updates (Optional, Boolean): If set to True, all updates that were queued while the bot was offline will be discarded upon setting the webhook.23secret_token (Optional, String): A crucial security feature. If set, every webhook request from Telegram will include the X-Telegram-Bot-Api-Secret-Token header with this value. This allows your server to verify that the request is genuinely from Telegram and not from a malicious actor.23Payload Deep DiveRequest Structure (setWebhook):JSON{
    "url": "https://your-domain.com/path/to/webhook",
    "max_connections": 40,
    "secret_token": "a_very_secret_string_123",
    "drop_pending_updates": true,
    "allowed_updates": ["message", "callback_query"]
}
Success Payload (setWebhook):JSON{
    "ok": true,
    "result": true,
    "description": "Webhook was set"
}
Incoming Webhook Payload: When an update occurs, Telegram sends a POST request to your URL. The body of this request is the raw JSON of a single Update object. Your server must be configured to parse this JSON body.Local Development with Webhooks using ngrokTo test a webhook-based bot locally, you need a way to expose your local server (e.g., running on localhost:8000) to a public HTTPS URL. Tunneling services like ngrok are designed for this purpose.16Run Your Local Bot Server: Start your bot application, configured to listen for HTTP requests on a local port (e.g., 8000).Start ngrok: Run the ngrok command to create a tunnel to your local port: ngrok http 8000.Get Public URL: ngrok will provide a public HTTPS URL (e.g., https://abcdef1234.ngrok.io).Set the Webhook: Use this ngrok URL when calling the setWebhook method.Now, all updates from Telegram will be tunneled by ngrok to your local machine, allowing you to develop and debug your webhook logic without deploying to a live server.It is critical to remember that you cannot use both methods simultaneously. If a webhook is set, any calls to getUpdates will fail until the webhook is removed by calling setWebhook with an empty URL or by using the deleteWebhook method.72.3 The Update Object: Anatomy of an EventThe Update object is the central data structure in the Bot API. Every event, from a user sending a message to clicking a button, is encapsulated within an Update object and delivered to your bot.35 A deep understanding of its structure is fundamental to building the routing logic that directs incoming events to the correct processing functions.Each Update object has two main components:update_id: A unique, sequentially increasing integer identifier for the update. This is used for the offset parameter in polling.25One and only one of the other fields, which corresponds to the type of event that occurred. For example, if a user sends a new message, the message field will be present and all others (like callback_query, inline_query, etc.) will be absent.36The following table breaks down the most common update types, the Update field they populate, the primary object they contain, and the key data you will extract from that object. This serves as a quick-reference guide for building your bot's core handlers.User ActionUpdate FieldPrimary Object TypeKey Data FieldsSends a new message (text, photo, etc.)messageMessagemessage.text, message.chat.id, message.from.id, message.photo, message.locationEdits an existing messageedited_messageMessageedited_message.text, edited_message.chat.id, edited_message.edit_dateSends a message in a channelchannel_postMessagechannel_post.text, channel_post.chat.idEdits a message in a channeledited_channel_postMessageedited_channel_post.text, edited_channel_post.chat.idClicks an inline keyboard buttoncallback_queryCallbackQuerycallback_query.data, callback_query.from.id, callback_query.message.chat.idTypes @botname query in any chatinline_queryInlineQueryinline_query.query, inline_query.from.idAnswers a pollpoll_answerPollAnswerpoll_answer.poll_id, poll_answer.user.id, poll_answer.option_idsUser's status in a chat changeschat_memberChatMemberUpdatedchat_member.chat.id, chat_member.new_chat_member.statusBot receives a join requestchat_join_requestChatJoinRequestchat_join_request.chat.id, chat_join_request.from.idYour bot's initial logic will involve inspecting the incoming Update object to determine which of these fields is present, and then passing the contained object (e.g., the Message or CallbackQuery object) to the appropriate function for processing. Libraries like python-telegram-bot simplify this with a handler system, where you register different functions to handle different update types automatically.Part II: Building Interactive ExperiencesThis part transitions from the foundational mechanics of receiving data to the practical implementation of engaging user interactions. It covers the full spectrum of communication tools available, from richly formatted text and media to dynamic, interactive keyboards and the integrated gaming platform.Section 3: Mastering Core CommunicationEffective communication is the bedrock of any successful bot. This section provides a granular breakdown of the primary methods for sending content, focusing on text messages, advanced formatting, and various media types.3.1 The sendMessage Method: A Detailed BreakdownThe sendMessage method is the most fundamental and frequently used action in the Bot API. It is the primary tool for sending text-based responses to users.8 While its basic function is simple, it supports a wide range of optional parameters that enable rich, contextual interactions.Endpoint: POST https://api.telegram.org/bot<token>/sendMessageParameters:chat_id (Required, Integer or String): Unique identifier for the target chat. This can be a user's ID for a private message, or a group/channel ID. For public channels, you can also use the format @channelusername.39text (Required, String): The text of the message to be sent. It must be between 1 and 4096 characters after entities parsing.39parse_mode (Optional, String): Mode for parsing entities in the message text. Valid options are MarkdownV2, HTML, or the legacy Markdown. This allows for text formatting like bold and italics. See Section 3.2 for a detailed guide.37entities (Optional, Array of MessageEntity): A JSON-serialized list of special entities (e.g., mentions, hashtags, URLs) that appear in the text. This can be used as an alternative to parse_mode for programmatic formatting.39link_preview_options (Optional, LinkPreviewOptions): A JSON-serialized object to control link preview generation options, such as disabling previews or choosing the preview position.39 The older disable_web_page_preview parameter is still supported for backward compatibility.37disable_notification (Optional, Boolean): If True, the message is sent silently. Users will receive a notification with no sound.37protect_content (Optional, Boolean): If True, the contents of the sent message are protected from forwarding and saving.39reply_parameters (Optional, ReplyParameters): A JSON-serialized object describing the message to reply to. This is the modern way to handle replies and quotes, replacing the older reply_to_message_id.39reply_markup (Optional, InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply): A JSON-serialized object for adding interactive elements like inline keyboards or custom reply keyboards to the message.39message_thread_id (Optional, Integer): For sending messages to a specific topic within a forum-enabled supergroup.39business_connection_id (Optional, String): Unique identifier of a business connection on behalf of which the message will be sent.39Payload Deep DiveRequest Structure (JSON Body):JSON{
    "chat_id": 123456789,
    "text": "This is a *bold* message replying to another message.\nCheck out this link:(https://telegram.org/)",
    "parse_mode": "MarkdownV2",
    "link_preview_options": {
        "is_disabled": false,
        "url": "https://telegram.org/",
        "prefer_small_media": true
    },
    "reply_parameters": {
        "message_id": 42
    },
    "reply_markup": {
        "inline_keyboard":
    }
}
Success Payload Structure:A successful call to sendMessage returns "ok": true and a "result" field containing the full Message object that was just sent. This is useful for obtaining the message_id of the new message, which might be needed for subsequent edits or deletions.JSON{
    "ok": true,
    "result": {
        "message_id": 43,
        "from": {
            "id": 1234567890,
            "is_bot": true,
            "first_name": "My Bot",
            "username": "MyBot"
        },
        "chat": {
            "id": 123456789,
            "first_name": "John",
            "username": "johndoe",
            "type": "private"
        },
        "date": 1678886401,
        "text": "This is a bold message replying to another message.\nCheck out this link: Telegram",
        "entities": [
            { "offset": 10, "length": 4, "type": "bold" },
            { "offset": 58, "length": 8, "type": "text_link", "url": "https://telegram.org/" }
        ],
        "reply_to_message": {
            "message_id": 42
            /*... full original message object... */
        }
    }
}
3.2 Advanced Text Formatting: Mastering parse_modeProperly formatting text is essential for creating clear, readable, and engaging bot messages. The parse_mode parameter in sendMessage and other methods controls how Telegram interprets markup in your text.37 Incorrectly formatted text is a common source of 400 Bad Request errors, making a precise understanding of the syntax rules critical.Telegram supports two primary, modern formatting styles: MarkdownV2 and HTML. A legacy Markdown style also exists but is retained only for backward compatibility and should be avoided in new projects due to its limited features and inconsistent escaping rules.42MarkdownV2 StyleThis is the recommended and most powerful markup style. It requires escaping of the special characters _, *, [, ], (, ), ~, `, >, #, +, -, =, |, {, }, ., ! with a preceding backslash \.42HTML StyleThis style uses standard HTML tags. It is often more familiar to web developers and can be less prone to escaping issues with plain text. The only characters that must be escaped are <, >, and &, which should be replaced with their corresponding HTML entities: &lt;, &gt;, and &amp;.37A critical and often overlooked detail is that Telegram's API calculates entity offsets and lengths based on UTF-16 code units, not Python string characters or UTF-8 bytes. For most text within the Basic Multilingual Plane (BMP), this is a 1:1 mapping. However, characters outside the BMP (like many emojis) are represented by two UTF-16 code units (a surrogate pair), and thus count as having a length of 2.43 This is particularly important for developers who construct the entities array manually instead of using parse_mode.The following table provides a quick-reference comparison for formatting syntax, which is invaluable for avoiding common parsing errors.Formatting TypeMarkdownV2 SyntaxHTML SyntaxNotes & EscapingBold*bold text*<b>bold text</b> or <strong>bold text</strong>In MarkdownV2, * must be escaped as \*.Italic_italic text_<i>italic text</i> or <em>italic text</em>In MarkdownV2, _ must be escaped as \_. Note: Cannot be the last character.Underline__underline text__<u>underline text</u> or <ins>underline text</ins>---Strikethrough~strikethrough text~<s>strikethrough text</s> or <strike> or <del>In MarkdownV2, ~ must be escaped as \~.Spoiler`spoiler textInline Link[link text](http://example.com)<a href="http://example.com">link text</a>In MarkdownV2, [, ], (, ) must be escaped.Inline Code`fixed-width code`<code>fixed-width code</code>In MarkdownV2, ` must be escaped as ```.Pre-formatted Block```\ncode block\n```<pre>code block</pre>MarkdownV2 supports language hints: ```python\ncode\n```Blockquote>Blockquote text<blockquote>Blockquote text</blockquote>Added in recent API versions.3.3 Sending Media: A Complete TutorialBeyond text, bots can send a wide array of media types, making interactions more dynamic and informative. The API provides a dedicated method for each primary media type, such as sendPhoto, sendVideo, sendAudio, sendDocument, sendAnimation, and sendVoice.44There are three ways to specify the file to be sent 46:By file_id: This is the most efficient method. When your bot receives or sends a file, the corresponding Message object contains a file_id. This is a unique string identifier for the file on Telegram's servers. You can store this file_id and use it to send the exact same file again without re-uploading it. This saves bandwidth, reduces latency, and is the recommended approach for frequently sent media.47By URL: You can provide a public HTTP URL to a file. Telegram's servers will download the file from that URL and then send it to the user. This is convenient for sending files hosted elsewhere on the web.46By Uploading: You can upload a file directly from your server. This is done by sending a multipart/form-data request. Libraries like python-telegram-bot abstract this complexity, allowing you to simply provide a local file path or a file-like object (e.g., open('my_image.jpg', 'rb')).48The practice of storing and reusing file_ids is a cornerstone of efficient bot design. For any media-heavy bot, implementing a caching or database layer to store the file_ids of commonly used assets is a critical optimization. This "file_id economy" drastically reduces the bot's operational costs and improves its responsiveness by minimizing slow and data-intensive file uploads.Sending Media Groups (sendMediaGroup)To send an album of photos or videos, the sendMediaGroup method is used. This method takes a chat_id and a media parameter, which is a JSON-serialized array of InputMedia objects (e.g., InputMediaPhoto, InputMediaVideo).51A crucial and non-obvious rule governs captions for media groups: to set a caption for the entire album, you must provide the caption parameter only for the first item in the media array. If you provide captions for other items, they will only be visible when the user views that specific photo or video individually.51Example Request (sendMediaGroup with python-telegram-bot):Pythonfrom telegram import InputMediaPhoto

media_group =
await bot.send_media_group(chat_id=update.effective_chat.id, media=media_group)
Section 4: Advanced User Interaction with KeyboardsKeyboards are the primary mechanism for guiding user interaction, moving beyond free-form text input to structured, menu-driven conversations. The Bot API offers two distinct types of keyboards: Reply Keyboards and Inline Keyboards.4.1 ReplyKeyboardMarkup: Crafting Custom Reply and Request ButtonsA ReplyKeyboardMarkup replaces the user's standard text keyboard with a grid of custom buttons.52 When a user taps one of these buttons, the button's text is sent to the chat as a standard text message, which your bot then processes.These keyboards are constructed from an array of arrays of KeyboardButton objects, where each inner array represents a row of buttons.52KeyboardButton TypesText Button: The default type. It simply sends its text label as a message.Request Buttons: Special buttons that can request user information. These are only available in private chats with the bot.57request_contact=True: Prompts the user to share their phone number. The bot receives a Message with a Contact object.53request_location=True: Prompts the user to share their current location. The bot receives a Message with a Location object.57request_poll: Prompts the user to create and send a poll.57request_users and request_chat: Prompts the user to select and share one or more users or a chat, respectively.57Web App Button: A button with a web_app parameter will launch a specified Mini App.57It is important to note that the special request button types are mutually exclusive. A single KeyboardButton can only have one of these optional parameters set.57Configuration Optionsresize_keyboard (Boolean): If True, the keyboard's height is adjusted to fit the number of rows. Defaults to False.54one_time_keyboard (Boolean): If True, the keyboard is hidden as soon as the user presses a button. Defaults to False.54input_field_placeholder (String): Sets placeholder text to be shown in the message input field when the keyboard is active.54selective (Boolean): If True, the keyboard is only shown to specific users (e.g., users mentioned in the message or the user being replied to).54To remove a reply keyboard and restore the standard text keyboard, the bot must send a message with a ReplyKeyboardRemove object in the reply_markup field.524.2 InlineKeyboardMarkup: Building Dynamic Menus and InterfacesUnlike reply keyboards, an InlineKeyboardMarkup is displayed directly beneath a message it is attached to, within the chat interface itself.53 This makes it the ideal tool for creating interactive menus, confirmation dialogs, and other UI elements that don't disrupt the flow of conversation.Inline keyboards are composed of an array of arrays of InlineKeyboardButton objects. Each button can perform one of several actions:url: Opens the specified URL in the user's browser.52callback_data: This is the most powerful feature. When a user clicks a button with callback_data, no message is sent to the chat. Instead, a CallbackQuery update is sent silently to your bot in the background. The callback_data is a string (up to 64 bytes) that you define, which your bot uses to identify which button was pressed.52web_app: Launches the specified Mini App.login_url: A special URL used for a Telegram Login widget.switch_inline_query: Prompts the user to select a chat, then switches to inline mode in that chat with the specified query.callback_game: Used to launch a game.35The ability to send a callback_data string silently to the bot is what enables the creation of complex, stateful interfaces. A bot can present a set of options (buttons), receive a callback_data string indicating the user's choice, perform a backend action (like updating a database), and then use the editMessageText or editMessageReplyMarkup methods to change the original message, presenting a new set of options or updated information.62 This cycle of display state -> receive action -> update state -> display new state perfectly mirrors the behavior of a Finite State Machine (FSM). This makes inline keyboards the primary tool for implementing multi-step conversational flows, such as those found in wizards, forms, or navigation menus, without flooding the chat with messages from the user.4.3 Handling User Input: The CallbackQuery Object ExplainedWhen a user clicks an inline button with callback_data, the bot receives an Update containing a CallbackQuery object. A precise understanding of this object and the required response is vital for creating a responsive bot.The CallbackQuery object contains several key fields 62:id (String): A unique identifier for this specific query.from (User): The User object representing the user who clicked the button.message (Optional, Message): The original message to which the inline keyboard was attached.inline_message_id (Optional, String): If the message was sent via inline mode, this will be present instead of message.chat_instance (String): A global identifier for the chat where the button was clicked.data (Optional, String): The callback_data string that was defined for the button. This is the payload your bot will parse to determine what action to take.The answerCallbackQuery ImperativeAfter receiving a CallbackQuery, a bot must call the answerCallbackQuery method in response. This call acknowledges receipt of the query and signals to the user's Telegram client that the button press has been processed. If this method is not called, the client will display a persistent loading animation on the button for up to 10 seconds, leading to a poor user experience.52The answerCallbackQuery method itself can be used to provide feedback to the user:callback_query_id (Required, String): The id from the received CallbackQuery object.text (Optional, String): Text to be displayed as a notification at the top of the user's screen or as an alert box.show_alert (Optional, Boolean): If True, a pop-up alert box with the text is shown, which the user must dismiss. If False (default), a brief, unobtrusive notification is shown.url (Optional, String): A URL that will be opened by the client.cache_time (Optional, Integer): The maximum time in seconds for which the result of the callback query may be cached client-side.Payload Deep DiveIncoming Update with CallbackQuery:JSON{
    "update_id": 123456790,
    "callback_query": {
        "id": "4382bfdw6313827452",
        "from": {
            "id": 987654321,
            "is_bot": false,
            "first_name": "John",
            "username": "johndoe"
        },
        "message": {
            /*... full Message object... */
        },
        "chat_instance": "-568325423523825",
        "data": "confirm_order:item_id_42"
    }
}
Request (answerCallbackQuery):JSON{
    "callback_query_id": "4382bfdw6313827452",
    "text": "Your order has been confirmed!",
    "show_alert": false
}
Success Payload (answerCallbackQuery):JSON{
    "ok": true,
    "result": true
}
Section 5: The Gaming PlatformTelegram provides a dedicated Gaming Platform that allows bots to offer rich, interactive HTML5 games that can be played solo or competitively within chats.13 This platform is distinct from, but can be considered a specialized precursor to, the more general-purpose Mini Apps.5.1 Creating and Registering Your HTML5 Game with @BotFatherThe process of integrating a game begins with registering it on the platform via @BotFather.Issue the Command: Start a chat with @BotFather and send the /newgame command.13Provide Details: BotFather will guide you through a series of prompts:Description: A text description of your game.Photo: A static image that represents your game.GIF (Optional): An animated GIF that demonstrates gameplay. This is highly recommended as it makes the game message much more engaging.13Receive the game_short_name: Upon successful registration, your game will be assigned a unique game_short_name (e.g., my_awesome_game). This short name is the identifier you will use in the API to refer to your game.68The game itself is a standard HTML5 web application that you must host on your own HTTPS-enabled server.685.2 Launching and Sharing Games: The sendGame Method and CallbackGameOnce a game is registered, your bot can send it to a chat.Send the Game Message: Use the sendGame method, providing the chat_id and the game_short_name you received from BotFather.35 The message sent to the user will automatically include an inline "Play" button.13Handle the Play Button Click: When a user clicks the "Play" button, your bot receives a CallbackQuery update. This is similar to a standard inline button click, but the payload will contain a game_short_name field instead of a data field. The python-telegram-bot library represents this with a CallbackGame object.35Provide the Game URL: Your bot's handler for this CallbackQuery must call the answerCallbackQuery method. In the parameters for this method, you must provide the url of your hosted HTML5 game. This URL can be dynamically generated and can include user-specific parameters (like a session token) to authenticate the player.13Launch the Game: After your bot responds with the URL, the user's Telegram client will open the game in a dedicated in-app browser, and the game session begins.135.3 Managing Competition: setGameScore and getGameHighScoresA key feature of the Gaming Platform is its integrated high score and leaderboard system.Reporting Scores: The game logic, running in the user's browser, cannot directly call the Telegram Bot API (as this would expose your secret bot token). Instead, when a user achieves a new score, the game's JavaScript should send this score to your own backend server.65 Your backend then validates the score and calls the setGameScore API method on behalf of the user.35setGameScore Parameters:user_id, score, and either chat_id and message_id (for a game in a chat) or inline_message_id.force (Boolean): If True, the score can be set even if it's lower than the user's current high score. Useful for correcting errors or banning cheaters.65disable_edit_message (Boolean): If False (default), the original game message in the chat will be automatically updated to reflect the new high scores, creating a live leaderboard.65Retrieving Scores: The getGameHighScores method allows your bot (or your game's backend) to retrieve the high score table for any game message.35 This data can then be passed to the HTML5 game itself to display an in-game leaderboard.Social Sharing: To encourage viral growth, you can include the telegram-games.js script in your game's HTML. This script provides the TelegramGameProxy.shareScore() function, which, when called (e.g., from a button click), will prompt the user to share their score and a link to the game with one of their contacts or groups.13Part III: Advanced Capabilities and CustomizationThis part delves into the most sophisticated features of the Telegram Bot API, focusing on location-based services and the powerful Mini App platform. These capabilities allow developers to move beyond simple chat interactions and build full-fledged applications within the Telegram ecosystem.Section 6: Deep Dive into Location-Based ServicesLocation data is a powerful tool for a wide range of bot applications, from local service finders to logistics and tracking tools. Telegram provides several mechanisms for handling location, each with its own use case and privacy considerations.6.1 Requesting User Location with KeyboardButtonThe most direct way to obtain a user's location is to explicitly ask for it. The API provides a secure, user-consent-driven mechanism for this using a special type of KeyboardButton.Implementation: To request a user's location, your bot sends a message with a ReplyKeyboardMarkup. This keyboard must contain a KeyboardButton object where the request_location parameter is set to true.53Pythonfrom telegram import KeyboardButton, ReplyKeyboardMarkup

location_button = KeyboardButton(text="Share My Location", request_location=True)
custom_keyboard = [[location_button]]
reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)
await update.message.reply_text("Please share your location to find nearby services:", reply_markup=reply_markup)
User Experience: When the user receives this message, they will see a button (e.g., "Share My Location"). Tapping this button will open a native Telegram interface asking for permission to share their current GPS location with the bot.Data Received: If the user consents, the bot receives a new Message update. This message will not contain text, but rather a Location object. The Location object contains the following key fields:longitude (Float): The geographic longitude.latitude (Float): The geographic latitude.horizontal_accuracy (Optional, Float): The radius of uncertainty for the location, in meters.Privacy and Limitations: This feature is designed with user privacy as a priority.It only works in private, one-on-one chats with the bot.58It is impossible for a bot to obtain a user's location without this explicit, user-initiated action. There are no API methods or workarounds to silently track a user or determine their location from their IP address, as all bot traffic is proxied through Telegram's servers, obscuring the user's IP.696.2 Live Location: Sending, Receiving, and TrackingFor applications that require real-time tracking, such as delivery services or coordinating meetups, Telegram offers a "Live Location" feature.Receiving Live Location: A user can choose to share their live location with a bot for a predefined duration (15 minutes, 1 hour, or 8 hours).71 The initial share sends a Message containing a Location object, just like a static location share. However, as the user moves, their Telegram client will periodically send updates. These updates do not arrive as new messages. Instead, they trigger an edited_message update, where the original message's Location object is updated with the new coordinates.73 This is a critical distinction: to track a live location, your bot must have a handler specifically for edited_message updates that contain a location.Sending Live Location: A bot can also send and update its own live location. This is a multi-step process:Initial Send: The bot sends an initial location using the sendLocation method, but includes the live_period parameter (an integer from 60 to 86400 seconds).76 This tells Telegram that the location is "live" and will be updated. The API response will contain the Message object of this initial location pin.Periodic Updates: The bot must then periodically call the editMessageLiveLocation method, providing the chat_id and message_id of the original message, along with the new latitude and longitude.76 This moves the pin on the user's map.Stopping the Share: To stop the live location, the bot calls stopMessageLiveLocation.6.3 The New Frontier: Geolocation Access within Mini AppsThe most significant recent advancement in location services is the ability for Mini Apps to request and use geolocation data directly. This feature, introduced in Bot API 8.0, transforms bots from passive recipients of coordinates into platforms for rich, interactive, map-based applications.12How it Works: Within the Mini App's JavaScript environment (loaded from telegram-web-app.js), developers can access the window.Telegram.WebApp.LocationManager object. This object provides methods to request location permission from the user and to receive continuous location updates.78Capabilities: This allows a Mini App to:Display the user's real-time position on an interactive map (e.g., using libraries like Leaflet.js or Mapbox).Build location-based games with dynamic points of interest.Create interactive guides for events or cities.Implement complex location-based services that were previously impossible with the standard bot location features.This shift to in-app geolocation represents a fundamental change in how developers should approach location-based services on Telegram. While the KeyboardButton method is still useful for simple, one-off location requests, any application requiring a sophisticated map interface or real-time interaction with geographic data should now be built as a Mini App. The bot's role evolves to become the entry point that launches the app and the secure backend that processes the location data sent from it.Section 7: Unleashing Full Potential with Mini Apps (Web Apps)Telegram Mini Apps (formerly known as Web Apps) are the platform's solution for creating rich, custom user interfaces that go far beyond the limitations of chat messages and keyboards. They are, in essence, full-fledged web applications that run within a seamless, integrated browser view inside Telegram.17.1 Introduction to Mini Apps: Replacing Websites Inside TelegramA Mini App is built using standard web technologies: HTML, CSS, and JavaScript.79 This allows developers to leverage the entire ecosystem of web development tools, frameworks (like React, Vue, or Angular), and libraries to create virtually any user experience imaginable.80Every Mini App is fundamentally linked to a Telegram bot. The bot serves as the entry point for launching the app and as the backend for processing data and interacting with the Telegram API.80 This tight integration enables powerful features, including:Seamless User Authorization: The app automatically knows which Telegram user is accessing it.Integrated Payments: Mini Apps can use Telegram's payment APIs to accept payments from users globally.78Dynamic Theming: The app can automatically adapt its color scheme to match the user's Telegram theme (light or dark).78Native Component Interaction: The app can interact with native Telegram UI elements, like the main button, back button, and pop-up notifications.78Advanced Device Access: Recent API updates have granted Mini Apps access to device hardware, including persistent storage, the camera, GPS, and motion sensors.127.2 Development and Deployment: A Step-by-Step TutorialCreating and launching a Mini App involves two main parts: building the web application and configuring the bot to launch it.1. Building the Web ApplicationThe core of a Mini App is a web page. The only Telegram-specific requirement is the inclusion of a special JavaScript library.Include the SDK Script: In the <head> of your index.html file, you must include the telegram-web-app.js script. This script is the bridge that enables communication between your web app and the Telegram client.79HTML<script src="https://telegram.org/js/telegram-web-app.js"></script>
Access the WebApp Object: Once the script loads, it creates a global object, window.Telegram.WebApp, which contains all the properties and methods needed to interact with the Telegram environment.79 For example, Telegram.WebApp.initData contains user information, and Telegram.WebApp.MainButton.show() displays the main action button at the bottom of the screen.Deployment: The web application must be hosted on a server that is accessible via HTTPS. For development and testing, a tunneling service like ngrok can be used, but for production, a proper hosting solution is required.842. Configuring the BotOnce your web app is deployed to a public HTTPS URL, you must tell your bot how to launch it. This is done via @BotFather.Set the Menu Button: The most common way to launch a "main" Mini App is via the menu button next to the text input field.Send the /mybots command to @BotFather.Select your bot and navigate to Bot Settings -> Menu Button.Choose Edit menu button URL and provide the HTTPS URL to your Mini App.79Launch from Keyboards: You can also launch a Mini App from a KeyboardButton (in a reply keyboard) or an InlineKeyboardButton by setting its web_app parameter to a WebAppInfo object containing the app's URL.577.3 The Bridge: Two-Way CommunicationEffective Mini Apps rely on seamless, bidirectional communication with their parent bot. This architecture allows for a clean separation of concerns: the Mini App handles the user interface (the "view"), while the bot manages the business logic and data persistence (the "controller" and "model").1. From Bot to Mini App: Initialization DataWhen a Mini App is launched, Telegram passes a set of initialization parameters to it, accessible via the window.Telegram.WebApp object. The most important of these is initData.78initData (String): A string containing a series of URL-encoded key-value pairs. This data includes user information (ID, name, username), chat information, and a hash.Security: The hash is a cryptographic signature of the other data fields, signed with your bot's API token. Your backend server must validate this hash to confirm that the data is authentic and has not been tampered with. The initDataUnsafe object provides the same data in a pre-parsed JSON format for convenience on the client-side, but it should never be trusted by your backend without validation against the initData hash.782. From Mini App to Bot: Sending Data BackThere are two primary methods for a Mini App to send data back to its bot, depending on how it was launched.sendData() (from KeyboardButton): If the Mini App was launched from a KeyboardButton in a reply keyboard, it can use the Telegram.WebApp.sendData(data) method. This method sends the provided string data back to the bot. The bot receives this as a Message object with the web_app_data field populated. This is ideal for form submissions or simple data inputs, as it doesn't require a separate backend endpoint for the Mini App to call.78answerWebAppQuery (from InlineKeyboardButton): For more interactive apps launched from an InlineKeyboardButton, direct communication is often handled via standard web requests (e.g., fetch) from the Mini App to your bot's backend server. However, to send a message into the chat on the user's behalf, the bot can use the answerWebAppQuery method. The Mini App provides the necessary query_id (from initData), and the bot uses this to send an InlineQueryResult back to the chat, effectively allowing the app to inject content into the conversation.87This architectural decoupling of the UI (Mini App) from the logic (bot backend) is a powerful paradigm. It allows front-end developers to build rich interfaces using web technologies, while backend developers can focus on creating a secure, stateful API for the app to consume. For any bot with complex UI requirements, this is the modern, scalable, and recommended architecture.Part IV: Integration, Deployment, and ReferenceThis final part addresses the integration of advanced technologies like Artificial Intelligence, provides a definitive guide to error handling as requested, and serves as a comprehensive reference for the API's data structures and responses.Section 8: Integrating Artificial IntelligenceIntegrating large language models (LLMs) like OpenAI's GPT series or Google's Gemini can transform a simple command-based bot into a sophisticated conversational agent. The bot acts as a user-friendly interface to the powerful capabilities of these AI models.8.1 Architecting an AI-Powered BotThe typical architecture for an AI-powered Telegram bot involves the bot serving as an intermediary between the user and the AI service.89User Input: The user sends a message to the bot.Bot Handler: The bot's message handler receives the user's text.API Call to AI: The bot constructs a request and sends it to the AI provider's API (e.g., OpenAI or Google Gemini). This request typically includes the user's message and, crucially, the preceding conversation history for context.AI Response: The AI service processes the request and returns a generated response.Relay to User: The bot receives the AI's response and forwards it to the user in the Telegram chat using the sendMessage method.Best Practices for Setup:Secure API Keys: The API key for your chosen AI service is a secret credential, just like your bot token. It must be stored securely using environment variables (.env file) and never exposed in client-side code or public repositories.90Define Personality and Purpose: Before writing code, define the bot's persona. Is it a helpful assistant, a witty character, or a formal business representative? This can be configured in the "system prompt" or initial instructions given to the AI model to guide its tone and style.94Clear Onboarding: Use a well-crafted welcome message (for the /start command) to introduce the bot, explain its capabilities, and set user expectations.948.2 Asynchronous AI Responses: Keeping Your Bot ResponsiveAPI calls to LLMs can take several seconds to complete. In a synchronous application, the entire bot would freeze while waiting for the AI's response, unable to handle messages from other users. This creates a poor user experience and is not scalable.Modern Python bot libraries like python-telegram-bot (v20+) and aiogram are built on Python's asyncio framework, which is designed to handle this exact problem.95Asynchronous Operations: When you make an API call to the AI service using an async-compatible library (like aiohttp or the official openai and google-generativeai Python clients), you use the await keyword. This tells the Python event loop to pause the execution of the current function, but not to block the entire program. While waiting for the AI response, the event loop is free to process other tasks, such as incoming messages from other users.98 This ensures the bot remains responsive at all times.Handling Streaming Responses: Some AI models can "stream" their responses, sending back the generated text word by word or chunk by chunk. This can make the bot feel much faster. However, when implementing this, a common pitfall is trying to edit the Telegram message with each tiny chunk using parse_mode. If a chunk ends with an opening markdown character (e.g., *) but not the closing one, the Telegram API will return a 400 Bad Request: can't parse entities error.101 To handle this gracefully, you can:Buffer the Chunks: Accumulate the chunks and only call edit_message_text at logical breaks (like the end of a sentence) or when the markdown syntax is valid.Disable Parsing During Stream: Set parse_mode=None for all intermediate edit_message_text calls, and then make a final call with the full text and the desired parse_mode once the stream is complete.1018.3 Context is King: Strategies for Managing Conversation HistoryLLMs are typically stateless; they have no inherent memory of past interactions. To create a coherent, multi-turn conversation, the bot must manage the conversation history and provide it as context with every new request.102History Format: The standard format for conversation history is a list of message objects, each with a "role" (user or assistant) and "content" (the text of the message).103Pythonconversation_history =
Storage:In-Memory: For simple bots or testing, you can store the conversation history for each chat in a Python dictionary in memory, keyed by chat_id. This data will be lost if the bot restarts.Persistent Storage: For production bots, the history must be stored persistently. A database like SQLite (for smaller bots) or PostgreSQL is ideal. The bot would retrieve the user's history from the database at the start of a new message, append the new message, send it to the AI, append the AI's response, and then save the updated history back to the database.102Managing Context Window: LLMs have a finite context window (a limit on the number of tokens they can process at once). As a conversation gets longer, you will eventually exceed this limit. Strategies to manage this include:Sliding Window: Simply discard the oldest messages from the history once a certain length is reached.Summarization: Periodically use a separate, cheaper AI call to summarize the oldest parts of the conversation, replacing many messages with a single summary message.1038.4 Practical Example: Connecting to an AI API (Google Gemini)This example demonstrates a complete, runnable bot using python-telegram-bot and Google's Gemini API. It includes in-memory conversation history management.Prerequisites:Bashpip install python-telegram-bot python-dotenv google-generativeai
.env file:BOT_TOKEN="YOUR_TELEGRAM_BOT_TOKEN"
GEMINI_API_KEY="YOUR_GEMINI_API_KEY"
bot.py file:Pythonimport os
import logging
import google.generativeai as genai
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters

# Load environment variables
load_dotenv()
TELEGRAM_TOKEN = os.getenv('BOT_TOKEN')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configure the Gemini AI model
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-pro')

# In-memory storage for conversation history {chat_id: [history]}
conversation_histories = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message when the /start command is issued."""
    chat_id = update.effective_chat.id
    # Clear any previous history for this chat
    if chat_id in conversation_histories:
        del conversation_histories[chat_id]
    await update.message.reply_text('Hello! I am an AI assistant powered by Gemini. How can I help you today?')

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles user messages, sends them to Gemini, and replies with the response."""
    chat_id = update.effective_chat.id
    user_message = update.message.text

    # Initialize chat history if it doesn't exist
    if chat_id not in conversation_histories:
        conversation_histories[chat_id] = model.start_chat(history=)

    chat = conversation_histories[chat_id]

    try:
        # Send a "typing..." action to the user
        await context.bot.send_chat_action(chat_id=chat_id, action='typing')

        # Send message to Gemini and get the response
        response = await chat.send_message_async(user_message)
        ai_response = response.text

        # Reply to the user
        await update.message.reply_text(ai_response)

    except Exception as e:
        logger.error(f"An error occurred: {e}")
        await update.message.reply_text("Sorry, I encountered an error while processing your request.")

def main() -> None:
    """Start the bot."""
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Run the bot using polling
    logger.info("Starting bot...")
    application.run_polling()

if __name__ == '__main__':
    main()
(This example is synthesized from concepts in 90).Section 9: Definitive Guide to API Responses and Error HandlingA production-quality bot must be able to handle API responses and errors gracefully. This section provides the exhaustive breakdown of success and failure payloads requested by the user, forming a blueprint for robust error handling.9.1 The Anatomy of a Successful API ResponseEvery successful request to the Telegram Bot API will return a JSON object with two top-level fields 3:ok (Boolean): This will always be true for a successful request.result: This field contains the actual response data. Its type and structure depend entirely on the method that was called.For example:getMe returns a User object in the result field.sendMessage returns the Message object that was sent.getUpdates returns an array of Update objects.setWebhook returns a boolean true.Your code should always check for the presence and value of the ok field before attempting to parse the result.9.2 A Comprehensive Catalog of API Error CodesWhen a request fails, the API returns a JSON object where ok is false. The response will also contain an error_code (Integer) and a description (String) that explains the error.3 The error_code is a standard HTTP status code (e.g., 400, 403, 429), while the description provides a more specific, human-readable reason for the failure.Building robust error handling requires mapping these responses to specific actions (e.g., retrying the request, notifying the developer, or informing the user). The following table provides the most comprehensive catalog of known errors, compiled from official documentation and community-sourced data.HTTP Statuserror_codedescription (verbatim)Common TriggersRecommended Developer Action400400Bad Request: chat not foundsendMessage, etc.The chat_id is invalid or the bot has never interacted with it. Deactivate this user/chat in your database. Log the error.400400Bad Request: user not foundgetChatMember, etc.The user_id provided is invalid. Log the error.400400Bad Request: message text is emptysendMessageThe text field was empty or missing. Fix the calling code.400400Bad Request: can't parse entitiessendMessageThe parse_mode was specified, but the text contains invalid markdown/HTML syntax. Check for unclosed tags or unescaped special characters.400400Bad Request: message to edit not foundeditMessageTextThe message you are trying to edit does not exist or was deleted. Handle this gracefully.400400Bad Request: message is not modifiededitMessageTextThe new text and keyboard are identical to the existing ones. This is not a critical error, but can be caught to avoid unnecessary API calls.400400Bad Request: BUTTON_URL_INVALIDsendMessageAn InlineKeyboardButton contains a malformed URL. Validate URLs before sending.400400Bad Request: Group migrated to supergroupsendMessageA group's ID has changed after migration. The error response may contain the new supergroup_id. Update your database with the new ID.401401UnauthorizedAny methodThe bot token is incorrect or has been revoked. Stop the bot and check your token. This is a fatal configuration error.403403Forbidden: bot was blocked by the usersendMessageThe user has blocked the bot. You can no longer send messages to this user. Mark the user as inactive in your database.403403Forbidden: bot was kicked from the group chatsendMessageThe bot has been removed from the group. Mark the group as inactive in your database.403403Forbidden: user is deactivatedsendMessageThe target user account has been deleted. Mark the user as inactive.403403Forbidden: bot can't initiate conversation with a usersendMessageA bot cannot send the first message. The user must start the conversation. This error indicates a logic flaw.409409Conflict: can't use getUpdates method while webhook is activegetUpdatesA webhook is set. You must call deleteWebhook before you can use polling. This is a state management error.429429Too Many Requests: retry after XAny methodYou have hit a rate limit. The response will include a retry_after parameter. Your code should wait for this duration and then retry the request (see exponential backoff).500500Internal Server ErrorAny methodAn error occurred on Telegram's side. These are usually transient. A retry mechanism is recommended.(Table synthesized from 34)9.3 Best Practices for a Resilient, Fault-Tolerant BotArmed with the knowledge of possible errors, you can write a bot that is resilient and fault-tolerant.Universal try...except Blocks: Every single API call should be wrapped in a try...except block to catch potential telegram.error.TelegramError exceptions (in python-telegram-bot). This prevents a single failed API call from crashing the entire bot.Logging: Implement comprehensive logging. Log every error with its full context (e.g., the method called, the parameters used, the chat_id involved). This is invaluable for debugging issues after they occur.19Rate Limit Handling: The 429 Too Many Requests error is common for bots with high traffic. Do not simply ignore it. The correct approach is to implement an exponential backoff strategy:Catch the 429 error.Read the retry_after value from the error response.Wait for that duration (plus a small random buffer).Retry the request.If it fails again, double the waiting time before the next retry, up to a maximum limit.Handling User/Group Deactivation: When you receive a 403 Forbidden error indicating the bot was blocked or kicked, your bot should update its internal database to mark that chat as inactive. This prevents the bot from repeatedly trying to send messages to an unreachable chat, which wastes resources and clutters logs.Health Checks: For webhook-based bots, implement a simple health check endpoint (e.g., /health) that returns a 200 OK status. This allows your hosting provider or monitoring service to verify that your bot application is running correctly.